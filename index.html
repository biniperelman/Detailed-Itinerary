<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gap Year Itinerary Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics and fixed chat box */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            padding-bottom: 200px; /* Space for the fixed chat box */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        .tab-button.active {
            background-color: #10b981; /* Emerald 500 */
            color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        .activity-table th {
            background-color: #f3f4f6;
        }
        .activity-table tr:nth-child(even) {
            background-color: #f9fafb;
        }
        .chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 90%;
            max-width: 400px;
            background: white;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Start collapsed */
            max-height: 4rem; 
            transition: max-height 0.3s ease-out;
        }
        .chat-container.open {
            max-height: 80vh;
        }
        .chat-messages {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .chat-input-area {
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
        }
        .message-bubble {
            max-width: 85%;
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            word-wrap: break-word;
        }
        .user-message {
            align-self: flex-end;
            background-color: #3b82f6; /* Blue 500 */
            color: white;
            border-bottom-right-radius: 0.25rem;
        }
        .gemini-message {
            align-self: flex-start;
            background-color: #d1fae5; /* Green 100 */
            color: #065f46; /* Green 800 */
            border-bottom-left-radius: 0.25rem;
        }
        .gemini-source {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.5rem;
            padding-left: 0.5rem;
            border-left: 2px solid #a7f3d0;
        }
    </style>
</head>
<body class="bg-gray-50">

<div id="loadingIndicator" class="fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-50">
    <div class="flex flex-col items-center">
        <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-emerald-500"></div>
        <p class="mt-4 text-emerald-600 font-semibold">Loading Itinerary Data...</p>
    </div>
</div>

<div class="container">
    <header class="text-center mb-10 p-6 bg-white shadow-lg rounded-xl">
        <h1 class="text-4xl font-extrabold text-gray-800">Gap Year UK Itinerary</h1>
        <p class="text-lg text-gray-500 mt-2">Interactive Daily Schedule & Logistics</p>
    </header>

    <div id="tabs-container" class="flex flex-wrap justify-center gap-2 mb-8 p-4 bg-white rounded-xl shadow-md">
        </div>

    <div id="content-container" class="bg-white p-6 rounded-xl shadow-lg">
        </div>
</div>

<div id="chat-box" class="chat-container">
    <div id="chat-header" class="p-4 bg-emerald-500 text-white flex justify-between items-center rounded-t-xl cursor-pointer">
        <h3 class="text-xl font-bold">Itinerary Assistant (Gemini)</h3>
        <button id="toggle-chat-btn" class="text-2xl font-bold p-1 leading-none rounded-full hover:bg-emerald-400">+</button>
    </div>

    <div id="chat-messages" class="chat-messages" style="display: none;">
        <div class="message-bubble gemini-message">
            Hello! I'm your Itinerary Assistant. Ask me anything about your schedule, logistics, or general travel questions.
        </div>
        </div>

    <div id="chat-input-area" class="chat-input-area" style="display: none;">
        <input type="text" id="chat-input" placeholder="Ask about the itinerary or UK travel..."
               class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-emerald-500 focus:border-emerald-500 mr-2 shadow-inner">
        <button id="send-btn"
                class="bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-3 px-4 rounded-lg transition duration-200 shadow-md flex items-center disabled:opacity-50">
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 00.183.69l.006.006A1 1 0 003 18h14a1 1 0 00.894-1.447l-7-14z"></path></svg>
        </button>
    </div>
</div>

<script type="module">
    // --- Firebase imports (Required for Env.) ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Global Variables (Provided by Canvas) ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
    const apiKey = ""; // Canvas provides the actual key at runtime

    // --- Firebase Initialization ---
    let app, db, auth;
    if (Object.keys(firebaseConfig).length > 0) {
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // Authentication logic
            onAuthStateChanged(auth, (user) => {
                if (!user) {
                    // Sign in with custom token if available, otherwise anonymously
                    (async () => {
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        } catch (error) {
                            console.error("Firebase sign-in failed:", error);
                            // Fallback to anonymous sign-in if custom token fails
                            if (!auth.currentUser) {
                                await signInAnonymously(auth).catch(err => console.error("Anonymous sign-in failed:", err));
                            }
                        }
                    })();
                }
            });
        } catch (error) {
            console.error("Firebase initialization failed:", error);
        }
    }

    // --- Core Itinerary Logic ---
    let itineraryData = [];
    let currentDay = '';

    const loadingIndicator = document.getElementById('loadingIndicator');
    const tabsContainer = document.getElementById('tabs-container');
    const contentContainer = document.getElementById('content-container');

    // !!! UPDATED to restrict the CSV export range to A:E to fix slow loading/deployment !!!
    // This reduces the file size by ignoring thousands of empty rows/columns in the full sheet export.
    const csvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRip3XVrk7VVTw8BTxJIFiEfr26jDhhuyMnGBDrB191c3wjVaz3DJ4ra4ZMrvXW0HbNAMl28rxMrqcB/pub?gid=0&range=A:E&output=csv'; 

    function showLoading(show) {
        loadingIndicator.style.display = show ? 'flex' : 'none';
    }

    function parseCSV(text) {
        const lines = text.trim().split('\n');
        // Handle potential empty or short CSV
        if (lines.length <= 1) return [];

        // Simple split for headers, removing quotes
        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
        const data = [];

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;

            // Regex to split by comma, but ignore commas inside double quotes
            // This is a robust way to handle cells with commas inside them (which are usually quoted)
            const row = line.match(/(".*?"|[^",\r\n]+)(?=\s*,|\s*$)/g) || [];
            
            // Clean up row content and match lengths
            const cleanedRow = row.map(c => c.trim().replace(/^"|"$/g, ''));
            
            if (cleanedRow.length > 0 && cleanedRow.length >= headers.length) {
                const item = {};
                headers.forEach((header, index) => {
                    // Use index to match data to headers, even if the data row is longer
                    if (cleanedRow[index] !== undefined) {
                        item[header] = cleanedRow[index];
                    } else {
                        item[header] = '';
                    }
                });
                data.push(item);
            } else if (cleanedRow.some(c => c.length > 0)) {
                console.warn(`Skipping malformed row ${i + 1}: ${line}`);
            }
        }
        return data.filter(item => Object.values(item).some(v => v)); // Filter out completely empty rows
    }


    function renderTabs(data) {
        // Find the most appropriate date header
        const allHeaders = Object.keys(data[0] || {});
        const dateHeader = allHeaders.find(key => key.toLowerCase().includes('day') && key.toLowerCase().includes('date')) || allHeaders[0];

        // Filter out empty/null values and get unique days
        const uniqueDays = [...new Set(data.map(item => item[dateHeader]).filter(d => d && d.trim()))];
        tabsContainer.innerHTML = '';

        uniqueDays.forEach((day, index) => {
            const button = document.createElement('button');
            button.className = 'tab-button px-4 py-2 text-sm font-medium rounded-full transition duration-150 hover:bg-emerald-100 hover:text-emerald-700 text-gray-700 bg-white shadow-sm';
            button.textContent = day;
            button.onclick = () => switchDay(day, dateHeader);
            tabsContainer.appendChild(button);

            if (index === 0) {
                currentDay = day;
                button.classList.add('active');
            }
        });
        if (uniqueDays.length > 0) {
            renderContent(currentDay, dateHeader);
        } else {
            contentContainer.innerHTML = '<p class="text-center text-gray-500 p-8">No itinerary data found or CSV is empty. Please check the "Day/Date" column header name.</p>';
        }
    }

    function switchDay(day, dateHeader) {
        currentDay = day;
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
            if (btn.textContent === day) {
                btn.classList.add('active');
            }
        });
        renderContent(day, dateHeader);
    }

    function renderContent(day, dateHeader) {
        const dayData = itineraryData.filter(item => item[dateHeader] === day);
        if (dayData.length === 0) {
            contentContainer.innerHTML = `<p class="text-center text-gray-500 p-8">No activities scheduled for ${day}.</p>`;
            return;
        }

        const headers = Object.keys(dayData[0]);
        // Filter out the date header and only show 4 key columns for a clean view
        const displayHeaders = headers.filter(h => h !== dateHeader).slice(0, 4); 

        let tableHtml = `
            <h2 class="text-2xl font-semibold text-gray-800 mb-6">${day} Activities</h2>
            <div class="overflow-x-auto rounded-lg border border-gray-200">
            <table class="min-w-full divide-y divide-gray-200 activity-table">
                <thead class="bg-gray-50">
                    <tr>
                        ${displayHeaders.map(h => `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${h}</th>`).join('')}
                    </tr>
                </thead>
                <tbody class="bg-white divide-y divide-gray-200">
        `;

        dayData.forEach(item => {
            tableHtml += '<tr>';
            displayHeaders.forEach(header => {
                tableHtml += `<td class="px-6 py-4 text-sm text-gray-700">${item[header] || '-'}</td>`;
            });
            tableHtml += '</tr>';
        });

        tableHtml += `
                </tbody>
            </table>
            </div>
        `;
        contentContainer.innerHTML = tableHtml;
    }

    async function loadItinerary() {
        showLoading(true);
        try {
            const response = await fetch(csvUrl);
            if (!response.ok) {
                const errorMessage = `Error loading itinerary data: HTTP error! status: ${response.status}. Please check the CSV link and ensure it is published correctly.`;
                throw new Error(errorMessage);
            }
            const csvText = await response.text();
            itineraryData = parseCSV(csvText);
            
            if (itineraryData.length === 0) {
                 throw new Error("The CSV file is empty or contains no detectable data. Please check your spreadsheet content.");
            }

            renderTabs(itineraryData);
        } catch (error) {
            console.error('Failed to load CSV:', error);
            contentContainer.innerHTML = `<p class="text-center text-red-500 font-semibold p-8">${error.message}</p>`;
        } finally {
            showLoading(false);
        }
    }

    // --- Gemini Chat Logic ---

    const chatBox = document.getElementById('chat-box');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const chatHeader = document.getElementById('chat-header');
    const chatInputArea = document.getElementById('chat-input-area');
    const toggleChatBtn = document.getElementById('toggle-chat-btn');

    let isChatOpen = false;

    // Set initial state to collapsed (not open) and adjust content/button text
    function setInitialChatState() {
        // We set to open=false and run toggleChat to achieve the initial closed state,
        // which correctly sets the class and visibility.
        isChatOpen = true; 
        toggleChat(); 
    }
    
    // Toggle chat box visibility
    function toggleChat() {
        isChatOpen = !isChatOpen;
        if (isChatOpen) {
            chatBox.classList.add('open');
            chatMessages.style.display = 'flex';
            chatInputArea.style.display = 'flex';
            toggleChatBtn.textContent = 'âˆ’';
            // Wait for the transition before scrolling
            setTimeout(() => scrollToBottom(), 300); 
        } else {
            chatBox.classList.remove('open');
            // Delay hiding content to allow CSS transition to finish
            setTimeout(() => {
                chatMessages.style.display = 'none';
                chatInputArea.style.display = 'none';
            }, 300); 
            toggleChatBtn.textContent = '+';
        }
    }

    chatHeader.addEventListener('click', toggleChat); 
    toggleChatBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent the click from bubbling up to the header's click event
        toggleChat();
    });

    function appendMessage(text, sender, sources = []) {
        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${sender === 'user' ? 'user-message' : 'gemini-message'}`;
        
        // Escape special characters in text before setting as HTML
        const safeText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        let contentHtml = `<p class="message-text">${safeText}</p>`;

        if (sender === 'gemini' && sources.length > 0) {
            contentHtml += `<div class="gemini-source mt-2 text-xs">
                <p class="font-bold mb-1">Sources:</p>
                <ul>
                    ${sources.map(s => `<li><a href="${s.uri}" target="_blank" class="hover:underline">${s.title || s.uri}</a></li>`).join('')}
                </ul>
            </div>`;
        }

        bubble.innerHTML = contentHtml;
        chatMessages.appendChild(bubble);
        scrollToBottom();
    }

    function scrollToBottom() {
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function createLoader() {
        const loader = document.createElement('div');
        loader.id = 'gemini-loader';
        loader.className = 'message-bubble gemini-message flex items-center';
        loader.innerHTML = `
            <div class="animate-pulse flex space-x-2">
                <div class="w-2 h-2 bg-emerald-600 rounded-full"></div>
                <div class="w-2 h-2 bg-emerald-600 rounded-full"></div>
                <div class="w-2 h-2 bg-emerald-600 rounded-full"></div>
            </div>
        `;
        chatMessages.appendChild(loader);
        scrollToBottom();
        return loader;
    }

    async function fetchWithExponentialBackoff(apiUrl, payload, maxRetries = 5) {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.status === 429 || response.status >= 500) {
                    if (attempt === maxRetries - 1) throw new Error("API request failed after all retries.");
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue; // Retry
                }

                if (!response.ok) {
                    // Attempt to parse error message if available
                    let errorDetails = `API returned status ${response.status}`;
                    try {
                        const errorJson = await response.json();
                        errorDetails += `: ${errorJson.error?.message || JSON.stringify(errorJson)}`;
                    } catch {
                        // Ignore if JSON parsing fails
                    }
                    throw new Error(errorDetails);
                }

                return response.json();

            } catch (error) {
                if (attempt === maxRetries - 1) throw error;
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    async function sendMessage() {
        const userQuery = chatInput.value.trim();
        if (!userQuery) return;

        appendMessage(userQuery, 'user');
        chatInput.value = '';
        sendBtn.disabled = true;

        const loader = createLoader();
        
        // 1. Prepare Context and Payload
        const itineraryContext = JSON.stringify(itineraryData, null, 2);
        
        // Use the first 5000 characters of the context to keep the prompt size reasonable
        const contextSnippet = itineraryContext.substring(0, 5000) + (itineraryContext.length > 5000 ? "\n[... itinerary data truncated for length ...]" : "");

        const systemPrompt = `You are a helpful and detailed itinerary assistant named 'Gemini'. The user is asking questions about the following travel plan. Base your primary answers on this data first. If the user asks a general question (like about weather, transportation, or local attractions not in the itinerary), use Google Search to provide an answer.

ITINERARY DATA:
---
${contextSnippet}
---

Answer all questions concisely and clearly. If the itinerary data is empty, state that and use Google Search for general travel help. If you cannot find the answer in the itinerary, state that and then use Google Search for general information if applicable.`;
        
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            // Enable Google Search for grounding general knowledge questions
            tools: [{ "google_search": {} }],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
        };

        try {
            const result = await fetchWithExponentialBackoff(apiUrl, payload);
            
            // 2. Process Response
            const candidate = result.candidates?.[0];
            let responseText = "I apologize, but I couldn't generate a response for that query.";
            let sources = [];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                responseText = candidate.content.parts[0].text;
                
                const groundingMetadata = candidate.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title); // Ensure sources are valid
                }
            }

            // 3. Display Response
            chatMessages.removeChild(loader);
            appendMessage(responseText, 'gemini', sources);

        } catch (error) {
            console.error("Gemini API Error:", error);
            if (chatMessages.contains(loader)) {
                chatMessages.removeChild(loader);
            }
            appendMessage(`Error: Could not connect to the assistant. Details: ${error.message}`, 'gemini');
        } finally {
            sendBtn.disabled = false;
        }
    }

    sendBtn.addEventListener('click', sendMessage);
    chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    // Initial setup and load
    document.addEventListener('DOMContentLoaded', () => {
        setInitialChatState();
        loadItinerary();
    });
</script>

</body>
</html>
